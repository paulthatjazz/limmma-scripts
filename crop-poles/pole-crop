#!/bin/bash

# In-Place Pole Cropping Script
# Crops global rasters to exclude poles, saves in same directory
# Usage: ./crop_poles_inplace.sh [directory] [-f]
# -f flag forces overwrite of existing files

# Don't exit on errors - handle them gracefully
set +e

# Configuration
FORCE_OVERWRITE=false
INPUT_DIR="."

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--force)
            FORCE_OVERWRITE=true
            shift
            ;;
        *)
            INPUT_DIR="$1"
            shift
            ;;
    esac
done
TEMP_DIR="./temp_processing"

# Safe global bounds (excluding poles)
GEOGRAPHIC_BOUNDS="-180 -85 180 85"

# File patterns to process
FILE_PATTERNS=("*.tif" "*.tiff" "*.TIF" "*.TIFF")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

check_dependencies() {
    log_info "Checking dependencies..."
    
    if ! command -v gdalwarp &> /dev/null; then
        log_error "gdalwarp not found. Please install GDAL."
        exit 1
    fi
    
    if ! command -v gdalinfo &> /dev/null; then
        log_error "gdalinfo not found. Please install GDAL."
        exit 1
    fi
    
    log_success "Dependencies OK"
}

setup_directories() {
    log_info "Setting up directories..."
    
    if [[ ! -d "$INPUT_DIR" ]]; then
        log_error "Input directory '$INPUT_DIR' does not exist"
        exit 1
    fi
    
    mkdir -p "$TEMP_DIR"
    log_success "Directories ready"
}

process_file() {
    local input_file="$1"
    local filename=$(basename "$input_file")
    local basename="${filename%.*}"
    local extension="${filename##*.}"
    local file_dir=$(dirname "$input_file")
    
    # Skip files that already have "_no_poles" in the name
    if [[ "$basename" == *"_no_poles"* ]]; then
        log_info "Skipping $filename (already processed)"
        return 0
    fi
    
    local output_file="$file_dir/${basename}_no_poles.${extension}"
    
    log_info "Processing: $input_file"
    
    # Check if input file has valid geospatial info
    if ! gdalinfo "$input_file" &> /dev/null; then
        log_warning "Skipping $filename - not a valid raster file"
        return 1
    fi
    
    # Check if output already exists
    if [[ -f "$output_file" ]] && [[ "$FORCE_OVERWRITE" != "true" ]]; then
        log_warning "Output file already exists: $output_file"
        log_info "Skipping $filename (use -f to force overwrite)"
        return 0
    fi
    
    # Crop to safe global bounds (excluding poles)
    log_info "  → Cropping poles from $filename"
    if gdalwarp -te $GEOGRAPHIC_BOUNDS \
                -t_srs EPSG:4326 \
                -overwrite \
                -q \
                "$input_file" \
                "$output_file"; then
        log_success "  → Created: $(basename "$output_file")"
        return 0
    else
        log_error "  → Failed to crop $filename"
        return 1
    fi
}

find_and_process_files() {
    local processed=0
    local failed=0
    local skipped=0
    
    log_info "Searching for raster files in $INPUT_DIR..."
    
    # Create a temporary file list
    local temp_file_list="$TEMP_DIR/file_list.txt"
    > "$temp_file_list"  # Clear the file
    
    # Find all matching files recursively
    for pattern in "${FILE_PATTERNS[@]}"; do
        find "$INPUT_DIR" -type f -name "$pattern" >> "$temp_file_list" 2>/dev/null || true
    done
    
    # Check if we found any files
    if [[ ! -s "$temp_file_list" ]]; then
        log_warning "No raster files found matching patterns: ${FILE_PATTERNS[*]}"
        return 1
    fi
    
    local total_files=$(wc -l < "$temp_file_list")
    log_info "Found $total_files files to process"
    echo
    
    # Process each file
    while IFS= read -r file; do
        case $(process_file "$file") in
            0) ((processed++)) ;;
            1) ((failed++)) ;;
            *) ((skipped++)) ;;
        esac
        echo
    done < "$temp_file_list"
    
    # Clean up temp file list
    rm -f "$temp_file_list"
    
    log_info "Processing complete!"
    log_success "Processed: $processed files"
    
    if [[ $skipped -gt 0 ]]; then
        log_info "Skipped: $skipped files"
    fi
    
    if [[ $failed -gt 0 ]]; then
        log_warning "Failed: $failed files"
    fi
}

cleanup() {
    log_info "Cleaning up temporary files..."
    rm -rf "$TEMP_DIR"
    log_success "Cleanup complete"
}

main() {
    echo "===========================================" 
    echo "    In-Place Pole Cropping Script"
    echo "==========================================="
    echo
    
    log_info "Processing directory: $INPUT_DIR"
    echo
    
    check_dependencies
    setup_directories
    
    # Set trap to cleanup on exit
    trap cleanup EXIT
    
    find_and_process_files
    
    echo
    log_success "All done! Check directories for *_no_poles.* files."
    echo
    echo "Files created:"
    echo "  → *_no_poles.* files: EPSG:4326, poles cropped to ±85°"
}

# Run main function
main "$@"
